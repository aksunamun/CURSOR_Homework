•	git config – команда для указания пользовательских настроек, таких как электронная почта, имя пользователя, формат и т.д.;<br>
для всех локальных репозиториев:<br>
        git config --global user.name blabla - устанавливает имя, которое будет отображаться в поле автора у выполняемых вами коммитов;<br>
        git config --global user.email blabla@bla - устанавливает адрес электронной почты, который будет отображаться в информации о выполняемых вами коммитах;<br>
для конкретного проекта (локального репозитория):  <br>
        git config user.name blabla;<br>
        git config user.email blabla@bla;<br><br>
•	git init [название проекта] - создаёт новый локальный репозиторий с заданным именем (то есть будет создана папка с названием проекта в котором будет находиться репозиторий);<br>
	git init ./  -  создаёт новый локальный репозиторий в текущей директории;<br><br>
•	git status - перечисляет все новые или изменённые файлы, которые нуждаются в фиксации;<br><br>
•	git add – ‘выделяет’ нужные файлы и создает ‘набор’, который потом можно закоммитить (сделать сохраненную версию);<br><br>
•	git commit -m " Добавьте здесь любое сообщение описывающее коммит" - фиксирует ‘выделенные’ командой git add изменения и сохраняет их в историю версий с именем, которое ты указал в ‘сообщении, описывающем коммит’;<br>
        git commit - в таком случае откроется текстовый редактор по умолчанию, в котором нужно будет описать коммит.  Если это произошло случайно, введите :q и нажмите Enter;<br><br>
•	git log - история коммитов для текущей ветки;<br>
	git log --follow [файл] - история изменений конкретного файла, включая его переименование;<br><br>
•	git checkout - команда для создания веток или переключения между ними;<br>
        git checkout [имя ветки] - переключяется на выбранную ветку и одновременно обновляет рабочую директорию до её состояния;<br>
        git checkout -b [имя ветки] - создаёт новую ветку с таким-то именем и одновременно переходит на нее;<br>
        git checkout -d [имя ветки] - удаляет выбранную ветку;<br><br>
•	git branch - отображает список веток в локальном репозитории. <br>
Текущая ветка будет помечена звездочкой ‘*’.<br>
        git branch [имя ветки] - создаёт новую ветку с таким-то именем;<br>
        git branch -d [имя ветки] - удаляет выбранную ветку;<br><br>
•	git push [удалённый репозиторий] [ветка] - помещает все изменения локальной ветки в удалённый репозиторий (чтобы сделать ветку доступной для других пользователей);<br><br>
•	git pull – позволяет получить изменения из удаленного репозитория в локальный рабочий каталог (обновить ваш локальный каталог на его последнюю версию из удаленного репозитория);<br><br>
•	git merge [имя ветки] - позволяет вносит изменения указанной ветки в текущую активную ветку (объединять активную ветку с какой-либо другой);<br><br>
        git diff [имя ветки источника] [имя целевой ветки] – позволяет просмотреть различия до слияния веток;<br><br>
•	git clone - используется для клонирования репозитория;<br>
клонирование репозитория на удаленном сервере:<br>
        git clone имя.пользователя@хост:/путь/до/репозитория;<br>
клонирование локального репозитория:<br>
        git clone /путь/до/репозитория;<br><br>


.gitignore файл - служит для указания в нём файлов и папок, которые необходимо скрыть от системы контроля версий git. <br><br>

Как правило, скрывают файлы или папки, которые автоматически генерируют своё содержимое, либо имеют конфигурационные параметры, которые могут различаться у тех, кто совместно работает над проектом.<br>
 Правила синтаксиса этого файла:<br>

•	Одна строчка - одно правило,<br>
•	Пустые строки игнорируются,<br>
•	Комментарии доступны через решётку(#) в начале строки,<br>
•	Символ "/" в начале строки указывает, что правило применяется только к файлам и папкам, которые располагаются в той же папке, что и сам файл .gitignore,<br><br>
•	Доступно использовать спецсимволы:<br>
- звёздочка(*) заменяет любое количество символов(ноль или больше);<br>
- вопросик(?) заменяет от нуля до одного символа. Можно размещать в любом месте правила;<br>
- две звёздочки(**) используются для указания любого количества поддиректорий, подробнее смотри ниже в примерах,<br>
- восклицательный знак(!) в начале строки означает инвертирование правила, необходим для указания исключений из правил игнорирования;<br>
- cимвол "\" используется для экранирования спецсимволов, например, чтобы игнорировать файл с именем "!readme!.txt", нужно написать такое правило: "\!readme!.txt",<br><br>
•	Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла.<br><br>


Advanced<br><br>
git revert - позволяет отменить уже опубликованные коммиты с помощью новых коммитов.<br>
Она создает новые коммиты, по одному на каждый отменяемый коммит. Таким образом, если нужно отменить все коммиты после aaaaaa:<br>
# можно перечислить отменяемые коммиты<br>
git revert bbbbbb cccccc dddddd<br><br>

# можно задать диапазон от более раннего к более позднему (новому)<br>
git revert bbbbbb..dddddd<br><br>

# либо в относительных ссылках<br>
git revert HEAD~2..HEAD<br><br>

# можно отменить коммит слияния, указывая явным образом номер предка (в нашем примере таких нет):<br>
git revert -m 1 abcdef<br><br>

# после этого подтвердите изменения:<br>
git commit -m'детальное описание, что и почему сделано'<br><br>

•	git reset - позволяет ‘сбросить’ индексирование (выделение командой add) файлов рабочего каталога до последнего состояния коммита;<br>
git reset HEAD [имя файла] - позволяет исключить такой-то файл из индекса (например, если случайно набрали git add * и проиндексировали все файлы);<br><br>
•	git rebase – ввозволяет интерактивно перемещаться между коммитами и редактировать их («перезаписывать историю»): изменять «сообщение» коммита, порядок следования коммитов (в том числе удалять ненужные), «уплотнять» (сливать в один) коммиты, разбивать коммит на несколько.<br><br>
•	git cherry-pick  - позволяет переносить отдельные коммиты из одного места репозитория в другое, обычно между ветками разработки и обслуживания.<br><br>
Чтобы использовать команду:<br>
1. Убедитесь, что вы находитесь в той ветке, к которой хотите применить коммит:<br>
git checkout master<br>
2. Выполните следующее:<br>
git cherry-pick [имя коммита]<br><br>
•	git stash – позволяет сохранить изменения на временной основе, не добавляя их в коммит.<br>
Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того, чтобы позже можно было вернуться в это же состояние.<br>
Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений (то есть создает "заначку", которую вы потом в любое время можете снова применить).<br>
git stash list – отображает список созданных "заначек";<br>
git stash apply [имя "заначки"] -  применить такую-то "заначку" (спрятанную работу), например git stash apply stash@{2};<br>
git stash apply - применить последнюю спрятанную работу;<br>
git stash apply –index - применить последнюю спрятанную работу + файлы в индексе;<br>
git stash branch - создает новую ветку с началом из того коммита, на котором вы находились во время прятанья, восстанавливает в ней вашу работу и затем удаляет спрятанное, если оно применилось успешно (удобно для того, чтобы легко восстановить свою работу, а затем поработать над ней в новой ветке);<br>
git stash drop [имя "заначки"] – удаляет спрятанную работу из стека;<br>
git stash pop - применяет спрятанные изменения и сразу же удаляет их из стека.
